/*
 * MapFileWriter.cpp
 *
 * SPDX-License-Identifier: MIT
 */

#include "MapFileWriter.h"

#include <iostream>

#define STR_SPACING1 30
#define STR_SPACING2 57

MapFileWriter::MapFileWriter(SymbolFile& symbolInformations, ImageFile* imageFile) : symbolInformations(symbolInformations), imageFile(imageFile) {

}

static void print_spacing(size_t wordSize, size_t headerSpacing, ofstream& output) {

	long long int offset = (long long int)headerSpacing - (long long int)wordSize;
	if (offset <= 0) {
		output << " ";
	}
	else {
		for (long long int i = 0; i < offset; i++) {
			output << " ";
		}
	}
}

bool MapFileWriter::WriteMapFile(ofstream& output) {
	output << " " << symbolInformations.GetModuleName() << endl;

	output << endl << "; Map file generated by sym2map" << endl << endl;

	if (imageFile != nullptr) {
		cout << "Writer has additional informations coming form the image file." << endl;

		output << " Preferred load address is " << setfill('0') << setw(8) << hex << imageFile->GetLoadAddress();
		output << endl << endl;

		if (imageFile->IsEntryPointPresent()) {
			output << " entry point at        " << setfill('0') << setw(4) << hex << imageFile->GetEntryPointSegmentNumber();
			output << ":" << setfill('0') << setw(8) << hex << imageFile->GetEntryPointOffset();
			output << endl << endl;
		}

		output << " Start         Length     Name                          Class" << endl;
		// STR_SPACING1 spaces between Name and Class (size of Name included)
		for (unsigned int i = 0; i < symbolInformations.GetSegments().size(); i++) {
			SegmentObject segmentObject = symbolInformations.GetSegments().at(i);
			for (unsigned int j = 0; j < imageFile->GetSections().size(); j++) {
				SectionObject section = imageFile->GetSections().at(j);
				if (section.GetSectionNumber() == segmentObject.GetSegmentNumber()) {
					output << " " << setfill('0') << setw(4) << hex << segmentObject.GetSegmentNumber();
					output << ":00000000";
					output << " " << setfill('0') << setw(8) << hex << section.GetSectionSize();
					output << "H  " << section.GetSectionName();
					print_spacing(section.GetSectionName().size(), STR_SPACING1, output);
					output << (section.IsDataSection() ? "DATA" : "CODE");
					output << endl;
					break;
				}
			}
		}
		output << endl;
	}

	output << "  Address         ";
	if (imageFile != nullptr) {
		output << "Publics by Value";
		output << "                                         Rva+Base";
	}
	else {
		output << "Publics by Name ";
	}
	output << endl;
	// Spacing: STR_SPACING2
	for (unsigned int i = 0; i < symbolInformations.GetSegments().size(); i++) {
		SegmentObject segmentObject = symbolInformations.GetSegments().at(i);
		const SectionObject* sectionPtr = nullptr;
		if (imageFile != nullptr) {
			for (unsigned int k = 0; k < imageFile->GetSections().size(); k++) {
				SectionObject section = imageFile->GetSections().at(k);
				if (section.GetSectionNumber() == segmentObject.GetSegmentNumber()) {
					sectionPtr = &section;
					break;
				}
			}
		}
		for (unsigned int j = 0; j < segmentObject.GetEditableSymbolsList().size(); j++) {
			SymbolObject symbolObject = segmentObject.GetEditableSymbolsList().at(j);
			output << " " << setfill('0') << setw(4) << hex << segmentObject.GetSegmentNumber();
			output << ":" << setfill('0') << setw(8) << hex << symbolObject.GetSymbolAddress();
			output << "    " << symbolObject.GetSymbolName();
			print_spacing(symbolObject.GetSymbolName().size(), STR_SPACING2, output);
			if (sectionPtr != nullptr) {
				output << setfill('0') << setw(8) << hex << (sectionPtr->GetRVABaseAddress() + symbolObject.GetSymbolAddress());
			}
			
			output << endl;
		}
	}
	return true;
}
